// ignore_for_file: prefer_const_constructor_declarations, cascade_invocations

// Generated by Dart Safe Data Class Generator. * Change this header on extension settings *
// ignore_for_file: type=lint
import 'package:flutter/material.dart';
import 'package:ispect/ispect.dart';
import 'package:ispect/src/common/observers/route_extension.dart';
import 'package:ispect/src/common/observers/transition.dart';

/// Extension on `StringBuffer` to conditionally write a line.
extension StringBufferExtension on StringBuffer {
  /// Writes `value` to the buffer if [condition] is true.
  // ignore: avoid_positional_boolean_parameters
  void writelnIf(bool condition, String value) {
    if (condition) writeln(value);
  }
}

/// A custom `NavigatorObserver` for logging navigation events.
///
/// This observer logs page transitions, modals, gestures, and other navigation events.
/// It provides callbacks for external listeners and allows filtering specific event types.
class ISpectNavigatorObserver extends NavigatorObserver {
  /// Creates an instance of `ISpectNavigatorObserver`.
  ///
  /// - `isLogGestures`: Whether to log user gestures.
  /// - `isLogPages`: Whether to log page navigations.
  /// - `isLogModals`: Whether to log modal transitions.
  /// - `isLogOtherTypes`: Whether to log other navigation types.
  ISpectNavigatorObserver({
    this.isLogGestures = false,
    this.isLogPages = true,
    this.isLogModals = false,
    this.isLogOtherTypes = true,
    this.onPush,
    this.onReplace,
    this.onPop,
    this.onRemove,
    this.onStartUserGesture,
    this.onStopUserGesture,
  });

  static const int _maxTransitions = 100;
  final List<RouteTransition> _transitions = [];

  List<RouteTransition> get transitions => List.unmodifiable(_transitions);

  void addTransition(RouteTransition transition) {
    _transitions.add(transition);
    if (_transitions.length > _maxTransitions) {
      _transitions.removeAt(0);
    }
  }

  final bool isLogGestures;
  final bool isLogPages;
  final bool isLogModals;
  final bool isLogOtherTypes;

  final void Function(Route<dynamic> route, Route<dynamic>? previousRoute)?
      onPush;
  final void Function({Route<dynamic>? newRoute, Route<dynamic>? oldRoute})?
      onReplace;
  final void Function(Route<dynamic> route, Route<dynamic>? previousRoute)?
      onPop;
  final void Function(Route<dynamic> route, Route<dynamic>? previousRoute)?
      onRemove;
  final void Function(Route<dynamic> route, Route<dynamic>? previousRoute)?
      onStartUserGesture;
  final VoidCallback? onStopUserGesture;

  @override
  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {
    onPush?.call(route, previousRoute);
    _logRouteEvent(TransitionType.push, route, previousRoute);
  }

  @override
  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {
    onReplace?.call(newRoute: newRoute, oldRoute: oldRoute);
    _logRouteEvent(TransitionType.replace, newRoute, oldRoute);
  }

  @override
  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {
    onPop?.call(route, previousRoute);
    _logRouteEvent(TransitionType.pop, previousRoute, route);
  }

  @override
  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {
    onRemove?.call(route, previousRoute);
    _logRouteEvent(TransitionType.remove, route, previousRoute);
  }

  @override
  void didStartUserGesture(
    Route<dynamic> route,
    Route<dynamic>? previousRoute,
  ) {
    if (isLogGestures) {
      _logRouteEvent(TransitionType.startUserGesture, route, previousRoute);
    }
    onStartUserGesture?.call(route, previousRoute);
  }

  @override
  void didStopUserGesture() {
    if (isLogGestures) {
      _logRouteEvent(TransitionType.stopUserGesture, null, null);
    }
    onStopUserGesture?.call();
  }

  /// Logs navigation events based on event type and route validation.
  void _logRouteEvent(
    TransitionType type,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  ) {
    if (!_shouldLog(route, previousRoute)) return;

    final timestamp = DateTime.now();
    final transition = _createRouteTransition(
      type: type,
      route: route,
      previousRoute: previousRoute,
      timestamp: timestamp,
    );

    addTransition(transition);

    final logMessage = _buildLogMessage(type, route, previousRoute);
    ISpect.logger.route(logMessage, transitionId: transition.id);
  }

  /// Generates a unique ID for route transitions using timestamp and hashCode.
  ///
  /// This approach ensures uniqueness by combining:
  /// - Microsecond precision timestamp (more precise than milliseconds)
  /// - Object hashCode to handle concurrent operations
  /// - Fallback to transition count for additional uniqueness
  int _generateTransitionId(DateTime timestamp, Route<dynamic>? route) {
    final baseId = timestamp.microsecondsSinceEpoch;
    final routeHash = route?.hashCode ?? 0;
    final sequenceNumber = _transitions.length;

    // Combine timestamp with route hash and sequence for uniqueness
    return baseId ^ (routeHash << 16) ^ sequenceNumber;
  }

  /// Creates a RouteTransition instance with proper ID generation.
  RouteTransition _createRouteTransition({
    required TransitionType type,
    required Route<dynamic>? route,
    required Route<dynamic>? previousRoute,
    required DateTime timestamp,
  }) {
    final id = _generateTransitionId(timestamp, route);

    return RouteTransition(
      id: id,
      from: previousRoute,
      to: route,
      type: type,
      timestamp: timestamp,
      arguments: route?.settings.arguments,
    );
  }

  /// Builds a structured log message for route transitions.
  String _buildLogMessage(
    TransitionType type,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  ) {
    final buffer = StringBuffer();
    final routeName = route.routeName;
    final routeType = route.routeType;
    final previousRouteName = previousRoute.routeName;
    final previousRouteType = previousRoute.routeType;

    buffer.writeln(
        '${type.title} | $previousRouteName ($previousRouteType) â†’ $routeName ($routeType)');

    // Arguments info (only if present)
    final arguments = route?.settings.arguments;
    if (arguments != null) {
      if (arguments is Map<String, dynamic>) {
        final formattedArgs = JsonTruncatorService.pretty(arguments);
        buffer.writeln('Arguments: ${formattedArgs}');
      } else {
        buffer.writeln('Arguments: $arguments');
      }
    }

    return buffer.toString().trim();
  }

  /// Determines whether a route transition should be logged based on route types and configuration.
  ///
  /// This method evaluates the combination of route types in the transition against
  /// logging configuration flags to determine whether logging should occur.
  ///
  /// The logic follows these rules:
  /// 1. If both routes are PageRoutes, log only if `isLogPages` is true
  /// 2. If both routes are ModalRoutes (excluding PageRoutes), log only if `isLogModals` is true
  /// 3. If routes are of mixed types (e.g., one PageRoute and one ModalRoute), do not log
  /// 4. For any other route type combinations, log only if `isLogOtherTypes` is true
  ///
  /// - `route`: The new/current route being navigated to
  /// - `previousRoute`: The previous route being navigated from
  ///
  /// Returns true if the route transition should be logged based on current settings.
  bool _shouldLog(Route<dynamic>? route, Route<dynamic>? previousRoute) {
    final routeIsPage = route is PageRoute;
    final prevRouteIsPage = previousRoute is PageRoute;

    // If both routes are PageRoutes
    if (routeIsPage && prevRouteIsPage) {
      // // If one route is PageRoute and the other is not, don't log
      // if (routeIsPage != prevRouteIsPage) {
      //   return false;
      // }
      return isLogPages;
    }

    // At this point, neither route is a PageRoute
    final routeIsModal = route is ModalRoute;
    final prevRouteIsModal = previousRoute is ModalRoute;

    // If both routes are ModalRoutes
    if (routeIsModal && prevRouteIsModal) {
      return isLogModals;
    }

    // If one route is ModalRoute and the other is not, don't log
    if (routeIsModal != prevRouteIsModal) {
      return false;
    }

    // At this point, routes are neither PageRoutes nor ModalRoutes
    return isLogOtherTypes;
  }
}
