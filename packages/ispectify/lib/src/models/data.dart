// Generated by Dart Safe Data Class Generator. * Change this header on extension settings *
// ignore_for_file: type=lint
import 'package:collection/collection.dart';
import 'package:ispectify/ispectify.dart';

/// A model class representing a structured log entry.
class ISpectLogData {
  /// Creates an instance of `ISpectLogData` to store log details.
  ///
  /// - `message`: The main log message.
  /// - `time`: The timestamp of the log entry. Defaults to `DateTime.now()`.
  /// - `logLevel`: The severity level of the log.
  /// - `exception`: Any associated exception.
  /// - `error`: Any associated error.
  /// - `stackTrace`: The stack trace for debugging.
  /// - `title`: An optional title for categorizing logs.
  /// - `pen`: ANSI color for styling logs.
  /// - `key`: A unique identifier for this log entry.
  /// - `additionalData`: Any extra metadata attached to the log.
  ISpectLogData(
    Object? message, {
    DateTime? time,
    this.logLevel,
    this.exception,
    this.error,
    this.stackTrace,
    this.title,
    this.pen,
    this.key,
    Map<String, dynamic>? additionalData,
  })  : message = message?.toString(),
        additionalData = additionalData == null
            ? null
            : Map<String, dynamic>.unmodifiable(
                Map<String, dynamic>.from(additionalData),
              ),
        _time = time ?? DateTime.now();

  /// The timestamp when the log entry was created.
  final DateTime _time;

  /// A unique identifier for the log entry.
  final String? key;

  /// The main log message.
  final String? message;

  /// The severity level of the log entry.
  final LogLevel? logLevel;

  /// An optional title for categorizing the log.
  final String? title;

  /// ANSI color styling for the log message.
  final AnsiPen? pen;

  /// Additional metadata associated with the log entry.
  final Map<String, dynamic>? additionalData;

  /// Any exception associated with the log entry.
  final Object? exception;

  /// Any error associated with the log entry.
  final Error? error;

  /// The stack trace associated with the log entry.
  final StackTrace? stackTrace;

  /// Returns the timestamp of the log.
  DateTime get time => _time;

  /// Returns the full message, including the stack trace if available.
  String get textMessage {
    final errMsg = (error != null)
        ? '$error'.truncate()
        : ((exception != null) ? '$exception' : ''.truncate());

    return '$messageText$errMsg$stackTraceText';
  }

  /// Returns a formatted log header including the title or key and timestamp.
  String get header => '[${title ?? key}] | $formattedTime\n';

  /// Returns the formatted stack trace if available, otherwise an empty string.
  String get stackTraceText =>
      (stackTrace != null && stackTrace != StackTrace.empty)
          ? '\nStackTrace: $stackTrace'
          : '';

  /// Returns the exception as a string if available, otherwise an empty string.
  String? get exceptionText =>
      exception != null ? '\n$exception'.truncate() : '';

  /// Returns the error as a string if available, otherwise an empty string.
  String? get errorText => error != null ? '\n$error'.truncate() : '';

  /// Returns the log message as a string, or an empty string if `null`.
  String get messageText => message.truncate() ?? '';

  /// Returns the formatted timestamp of the log entry.
  String get formattedTime => ISpectDateTimeFormatter(time).format;

  bool get isError =>
      logLevel == LogLevel.error ||
      logLevel == LogLevel.critical ||
      ISpectLogType.isErrorKey(key);

  /// Notifies the observer about this log entry.
  ///
  /// This method uses polymorphic dispatch to call the appropriate observer method.
  /// Subclasses can override this to customize which observer method is called.
  ///
  /// - `observer`: The observer to notify.
  void notifyObserver(ISpectObserver observer) {
    if (isError) {
      observer.onError(this);
    } else {
      observer.onLog(this);
    }
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    final mapEquals = const DeepCollectionEquality().equals;

    return other is ISpectLogData &&
        other._time == _time &&
        other.key == key &&
        other.message == message &&
        other.logLevel == logLevel &&
        other.title == title &&
        other.pen == pen &&
        mapEquals(other.additionalData, additionalData) &&
        other.exception == exception &&
        other.error == error &&
        other.stackTrace == stackTrace;
  }

  @override
  int get hashCode {
    return _time.hashCode ^
        key.hashCode ^
        message.hashCode ^
        logLevel.hashCode ^
        title.hashCode ^
        pen.hashCode ^
        additionalData.hashCode ^
        exception.hashCode ^
        error.hashCode ^
        stackTrace.hashCode;
  }

  @override
  String toString() {
    return '''ISpectLogData(
      key: $key,
      message: $message,
      logLevel: $logLevel,
      title: $title,
      pen: $pen,
      additionalData: $additionalData,
      exception: $exception,
      error: $error,
      stackTrace: $stackTrace,
      )''';
  }
}
